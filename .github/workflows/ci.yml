name: Main CI/CD

on:
  push:
  pull_request:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read
  actions: read
  # We are NOT uploading SARIF to Code Scanning (artifacts only)
  # security-events: write

env:
  TF_DIR: infra
  ECR_REPO_NAME: tangled-web-lab-dev-app
  TERRAFORM_VERSION: 1.9.5
  TARGET_IMAGE: bkimminich/juice-shop:latest

# =========================
# 1) SECURITY SCANS (matrix)
# =========================
jobs:
  security-scans:
    name: Security Scans
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        scanner:
          - name: gitleaks
          - name: semgrep
          - name: trivy

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # -------- GITLEAKS --------
      - name: Run Gitleaks
        if: matrix.scanner.name == 'gitleaks'
        uses: gitleaks/gitleaks-action@v2
        with:
          args: >
            detect --no-git --redact
            --report-format sarif
            --report-path gitleaks.sarif
          config-path: .gitleaks.toml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Upload Gitleaks artifact
        if: matrix.scanner.name == 'gitleaks' && always()
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-results
          path: gitleaks.sarif
          if-no-files-found: ignore

      # -------- SEMGREP --------
      - name: Run Semgrep
        if: matrix.scanner.name == 'semgrep'
        uses: semgrep/semgrep-action@v1
        with:
          config: p/owasp-top-ten
          generateSarif: "1"     # produces semgrep.sarif
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
        continue-on-error: true

      - name: Upload Semgrep artifacts
        if: matrix.scanner.name == 'semgrep' && always()
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-results
          path: |
            semgrep.sarif
            semgrep.json
          if-no-files-found: ignore

      # -------- TRIVY (IMAGE) --------
      - name: Set up Trivy cache
        if: matrix.scanner.name == 'trivy'
        run: |
          mkdir -p $HOME/.cache/trivy
      - name: Run Trivy (SARIF)
        if: matrix.scanner.name == 'trivy'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.TARGET_IMAGE }}
          format: sarif
          output: trivy.sarif
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
          ignore-unfixed: true
          exit-code: '0'           # <-- do not fail CI on findings
          timeout: '10m'
          cache-dir: ${{ runner.temp }}/trivy-cache
        continue-on-error: true

      - name: Generate SBOM (SPDX JSON)
        if: matrix.scanner.name == 'trivy'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.TARGET_IMAGE }}
          format: spdx-json
          output: sbom-spdx.json
        continue-on-error: true

      - name: Upload Trivy artifacts
        if: matrix.scanner.name == 'trivy' && always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-results
          path: |
            trivy.sarif
            sbom-spdx.json
          if-no-files-found: ignore

# =========================
# 2) BUILD / VERIFY IMAGE
# =========================
  build:
    name: Build & Prepare
    runs-on: ubuntu-latest
    needs: security-scans
    if: ${{ !cancelled() && (success() || needs.security-scans.result == 'failure') }}
    outputs:
      image-digest: ${{ steps.inspect.outputs.digest }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Pull and verify target image
        id: inspect
        run: |
          set -e
          docker pull "${{ env.TARGET_IMAGE }}"
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${{ env.TARGET_IMAGE }}" | cut -d'@' -f2)
          echo "digest=$DIGEST" >> "$GITHUB_OUTPUT"
          echo "Verified image ${{ env.TARGET_IMAGE }} @ $DIGEST"

# =========================
# 3) DEPLOY INFRASTRUCTURE
# =========================
  deploy:
    name: Deploy Infrastructure
    needs: [security-scans, build]
    runs-on: ubuntu-latest
    if: ${{ vars.AWS_ROLE_ARN != '' && vars.AWS_ACCOUNT_ID != '' && vars.AWS_REGION != '' && !cancelled() }}
    outputs:
      app_url: ${{ steps.deploy.outputs.app_url }}
      alb_dns: ${{ steps.tf_outputs.outputs.alb_dns }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-session-name: GitHubActions-${{ github.run_id }}

      - name: WhoAmI (AWS)
        run: |
          set -e
          aws sts get-caller-identity
          aws configure list

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Terraform Version / Dir
        run: |
          terraform -version
          echo "TF working dir: ${{ env.TF_DIR }}"

      - name: Terraform Format Check
        working-directory: ${{ env.TF_DIR }}
        run: terraform fmt -check -diff

      - name: Terraform Init
        working-directory: ${{ env.TF_DIR }}
        run: terraform init -input=false -no-color

      - name: Terraform Plan
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -e
          WORKSPACE=${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
          terraform workspace select "$WORKSPACE" || terraform workspace new "$WORKSPACE"
          terraform plan -input=false -no-color \
            -var="region=${{ vars.AWS_REGION }}" \
            -var="image_uri=${{ env.TARGET_IMAGE }}" \
            -out=tfplan

      - name: Terraform Apply
        working-directory: ${{ env.TF_DIR }}
        run: terraform apply -input=false -no-color tfplan

      - name: Get infrastructure outputs
        id: tf_outputs
        working-directory: ${{ env.TF_DIR }}
        run: |
          ALB_DNS=$(terraform output -raw alb_dns_name 2>/dev/null || echo "")
          if [ -z "$ALB_DNS" ]; then
            echo "Error: Could not retrieve ALB DNS name from Terraform outputs"
            exit 1
          fi
          echo "alb_dns=$ALB_DNS" >> "$GITHUB_OUTPUT"
          echo "app_url=http://$ALB_DNS" >> "$GITHUB_OUTPUT"

      - name: Ensure ECR & push retagged image
        run: |
          set -e
          aws ecr describe-repositories --repository-names "$ECR_REPO_NAME" >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name "$ECR_REPO_NAME" --image-scanning-configuration scanOnPush=true

          aws ecr get-login-password --region "${{ vars.AWS_REGION }}" \
            | docker login --username AWS --password-stdin "${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com"

          ECR_URI="${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com/${ECR_REPO_NAME}:${{ github.sha }}"
          docker pull "${{ env.TARGET_IMAGE }}"
          docker tag  "${{ env.TARGET_IMAGE }}" "$ECR_URI"
          docker push "$ECR_URI"
          echo "ECR_IMAGE=$ECR_URI" >> "$GITHUB_ENV"

      - name: Update ECS service with new image
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -e
          terraform apply -auto-approve -input=false -no-color \
            -var="region=${{ vars.AWS_REGION }}" \
            -var="image_uri=$ECR_IMAGE"

      - name: Wait for service to be stable & reachable
        id: deploy
        run: |
          set -e
          ALB_DNS="${{ steps.tf_outputs.outputs.alb_dns }}"
          APP_URL="http://${ALB_DNS}"
          echo "Waiting for application at ${APP_URL} to respond‚Ä¶"
          timeout 300 bash -c '
            until curl -fsS --max-time 10 "'"$APP_URL"'"; do
              echo "  still waiting..."
              sleep 10
            done
          '
          echo "app_url=$APP_URL" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Application deployed: $APP_URL"

# =========================
# 4) ZAP BASELINE (DAST)
# =========================
  security-testing:
    name: Security Testing (ZAP baseline)
    needs: deploy
    runs-on: ubuntu-latest
    # run even if earlier scans had errors, as long as deploy succeeded
    if: always() && needs.deploy.result == 'success'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.12.0
        with:
          target: ${{ needs.deploy.outputs.app_url }}
          cmd_options: '-a'
        continue-on-error: true

      - name: Upload ZAP results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: zap-results
          path: report_*

# =========================
# 5) ROLLBACK (only if deploy failed)
# =========================
  rollback:
    name: Rollback on Failure
    needs: [deploy]
    runs-on: ubuntu-latest
    if: ${{ needs.deploy.result == 'failure' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      - name: Terraform Rollback (placeholder)
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform init -input=false -no-color
          WORKSPACE=${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
          terraform workspace select "$WORKSPACE"
          echo "‚ö†Ô∏è Add rollback logic here (e.g., apply prior image tag)."

# =========================
# 6) CLEANUP
# =========================
  cleanup:
    name: Cleanup
    needs: [deploy, security-testing]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Clean up temporary resources
        run: echo "üßπ Cleanup complete."
