name: Main CI/CD

on:
  push:
  pull_request:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read
  security-events: write
  actions: read

env:
  TF_DIR: infra
  ECR_REPO_NAME: tangled-web-lab-dev-app
  TERRAFORM_VERSION: 1.9.5
  TARGET_IMAGE: bkimminich/juice-shop:latest

jobs:
  # -------- Security scans (matrix) --------
  security-scans:
    name: Security Scans
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        scanner:
          - name: gitleaks
            upload_sarif: true
          - name: semgrep
            upload_sarif: true
          - name: trivy
            upload_sarif: true

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---- Gitleaks ----
      - name: Run Gitleaks
        if: matrix.scanner.name == 'gitleaks'
        uses: gitleaks/gitleaks-action@v2
        with:
          # Pass args as if calling `gitleaks detect ...`
          args: >
            detect --no-git --redact
            --report-format sarif
            --report-path gitleaks-results.sarif
          config-path: .gitleaks.toml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Upload Gitleaks SARIF
        if: matrix.scanner.name == 'gitleaks' && always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: gitleaks-results.sarif
          category: gitleaks

      - name: Upload Gitleaks artifacts
        if: matrix.scanner.name == 'gitleaks' && always()
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-results
          path: gitleaks-results.sarif
          if-no-files-found: ignore

      # ---- Semgrep ----
      - name: Run Semgrep
        if: matrix.scanner.name == 'semgrep'
        uses: semgrep/semgrep-action@v1
        with:
          config: p/owasp-top-ten
          generateSarif: "1"
        env:
          # Optional; if you have a Semgrep SaaS token
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
        continue-on-error: true

      - name: Upload Semgrep SARIF
        if: matrix.scanner.name == 'semgrep' && always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep.sarif
          category: semgrep

      - name: Upload Semgrep artifacts
        if: matrix.scanner.name == 'semgrep' && always()
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-results
          path: |
            semgrep.sarif
            semgrep.json
          if-no-files-found: ignore

      # ---- Trivy ----
      - name: Run Trivy (SARIF)
        if: matrix.scanner.name == 'trivy'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.TARGET_IMAGE }}
          format: sarif
          output: trivy-results.sarif
        continue-on-error: true

      - name: Upload Trivy SARIF
        if: matrix.scanner.name == 'trivy' && always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-results.sarif
          category: trivy

      - name: Generate SBOM (SPDX JSON)
        if: matrix.scanner.name == 'trivy'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.TARGET_IMAGE }}
          format: spdx-json
          output: sbom-spdx.json

      - name: Upload Trivy artifacts
        if: matrix.scanner.name == 'trivy' && always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-results
          path: |
            trivy-results.sarif
            sbom-spdx.json
          if-no-files-found: ignore

  # -------- Build & prepare (verify image only) --------
  build:
    name: Build & Prepare
    runs-on: ubuntu-latest
    needs: security-scans
    if: ${{ !cancelled() && (success() || needs.security-scans.result == 'failure') }}
    outputs:
      image-digest: ${{ steps.inspect.outputs.digest }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Pull and verify target image
        id: inspect
        run: |
          set -e
          docker pull "${{ env.TARGET_IMAGE }}"
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${{ env.TARGET_IMAGE }}" | cut -d'@' -f2)
          echo "digest=$DIGEST" >> "$GITHUB_OUTPUT"
          echo "Verified image ${{ env.TARGET_IMAGE }} @ $DIGEST"

  # -------- Deploy infra + retag/push to ECR + update ECS + wait --------
  deploy:
    name: Deploy Infrastructure
    needs: [security-scans, build]
    runs-on: ubuntu-latest
    if: ${{ vars.AWS_ROLE_ARN != '' && vars.AWS_ACCOUNT_ID != '' && vars.AWS_REGION != '' && !cancelled() }}
    outputs:
      app_url: ${{ steps.deploy.outputs.app_url }}
      alb_dns: ${{ steps.tf_outputs.outputs.alb_dns }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-session-name: GitHubActions-${{ github.run_id }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Terraform Format Check
        working-directory: ${{ env.TF_DIR }}
        run: terraform fmt -check -diff

      - name: Terraform Init
        working-directory: ${{ env.TF_DIR }}
        run: terraform init -input=false

      - name: Terraform Plan
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -e
          WORKSPACE=${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
          terraform workspace select "$WORKSPACE" || terraform workspace new "$WORKSPACE"
          terraform plan -input=false \
            -var="region=${{ vars.AWS_REGION }}" \
            -var="image_uri=${{ env.TARGET_IMAGE }}" \
            -out=tfplan

      - name: Terraform Apply
        working-directory: ${{ env.TF_DIR }}
        run: terraform apply -input=false tfplan

      - name: Get infrastructure outputs
        id: tf_outputs
        working-directory: ${{ env.TF_DIR }}
        run: |
          ALB_DNS=$(terraform output -raw alb_dns_name 2>/dev/null || echo "")
          if [ -z "$ALB_DNS" ]; then
            echo "Error: Could not retrieve ALB DNS name from Terraform outputs"
            exit 1
          fi
          echo "alb_dns=$ALB_DNS" >> "$GITHUB_OUTPUT"
          echo "app_url=http://$ALB_DNS" >> "$GITHUB_OUTPUT"

      - name: Ensure ECR & push retagged image
        run: |
          set -e
          aws ecr describe-repositories --repository-names "$ECR_REPO_NAME" >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name "$ECR_REPO_NAME" --image-scanning-configuration scanOnPush=true

          aws ecr get-login-password --region "${{ vars.AWS_REGION }}" \
            | docker login --username AWS --password-stdin "${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com"

          ECR_URI="${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com/${ECR_REPO_NAME}:${{ github.sha }}"
          docker pull "${{ env.TARGET_IMAGE }}"
          docker tag  "${{ env.TARGET_IMAGE }}" "$ECR_URI"
          docker push "$ECR_URI"
          echo "ECR_IMAGE=$ECR_URI" >> "$GITHUB_ENV"

      - name: Update ECS service with new image
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -e
          terraform apply -auto-approve -input=false \
            -var="region=${{ vars.AWS_REGION }}" \
            -var="image_uri=$ECR_IMAGE"

      - name: Wait for service to be stable & reachable
        id: deploy
        run: |
          set -e
          ALB_DNS="${{ steps.tf_outputs.outputs.alb_dns }}"
          APP_URL="http://${ALB_DNS}"
          echo "Waiting for application at ${APP_URL} to respond‚Ä¶"
          timeout 300 bash -c '
            until curl -fsS --max-time 10 "'"$APP_URL"'"; do
              echo "  still waiting..."
              sleep 10
            done
          '
          echo "app_url=$APP_URL" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Application deployed: $APP_URL"

  # -------- DAST with ZAP --------
  security-testing:
    name: Security Testing (ZAP baseline)
    needs: deploy
    runs-on: ubuntu-latest
    if: ${{ needs.deploy.result == 'success' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.12.0
        with:
          target: ${{ needs.deploy.outputs.app_url }}
          cmd_options: '-a'
        continue-on-error: true

      - name: Upload ZAP results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: zap-results
          path: report_*

  # -------- Rollback (stub) --------
  rollback:
    name: Rollback on Failure
    needs: [deploy, security-testing]
    runs-on: ubuntu-latest
    if: ${{ failure() && needs.deploy.result == 'success' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      - name: Terraform Rollback (placeholder)
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform init -input=false
          WORKSPACE=${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
          terraform workspace select "$WORKSPACE"
          echo "‚ö†Ô∏è Add your rollback logic here (e.g., previous image tag)."

  # -------- Cleanup --------
  cleanup:
    name: Cleanup
    needs: [deploy, security-testing, rollback]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Clean up temporary resources
        run: echo "üßπ Cleanup complete."
