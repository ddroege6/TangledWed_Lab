name: Main CI/CD

on:
  push:
  pull_request:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read
  security-events: write

env:
  TF_DIR: infra
  ECR_REPO_NAME: tangled-web-lab-dev-app

jobs:
  gitleaks:
    name: Secret Scanning (fail-fast)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Install prerequisites
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y jq curl tar

      - name: Install Gitleaks (with fallback)
        run: |
          set -e
          GL=$(curl -fsSL https://api.github.com/repos/gitleaks/gitleaks/releases/latest | jq -r .tag_name || echo "v8.28.0")
          curl -fsSL "https://github.com/gitleaks/gitleaks/releases/download/${GL}/gitleaks_${GL#v}_linux_x64.tar.gz" -o gl.tgz
          tar -xzf gl.tgz gitleaks
          sudo install -m 0755 gitleaks /usr/local/bin/gitleaks
          gitleaks version

      - id: scan
        name: Run Gitleaks (JSON + SARIF, always upload)
        run: |
          set +e
          mkdir -p reports
          # Placeholders so upload never fails
          echo '{}' > reports/gitleaks.json
          printf '{ "version":"2.1.0", "runs":[] }' > reports/gitleaks.sarif

          BASE="gitleaks detect --no-banner --no-git --redact"
          if [ -f ".gitleaks.toml" ]; then
            BASE="$BASE --config .gitleaks.toml"
          fi

          echo "Running JSON scan…"
          eval "$BASE --report-format=json  --report-path reports/gitleaks.json"
          status_json=$?

          echo "Running SARIF scan…"
          eval "$BASE --report-format=sarif --report-path reports/gitleaks.sarif"
          status_sarif=$?

          # If either run found leaks (1) or errored (2), mark as non-zero
          if [ "$status_json" -ne 0 ] || [ "$status_sarif" -ne 0 ]; then
            status=1
          else
            status=0
          fi
          echo "exitcode=$status" >> "$GITHUB_OUTPUT"
          exit 0

      - name: Upload gitleaks reports (only)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: gitleaks-reports
          path: |
            reports/gitleaks.json
            reports/gitleaks.sarif
          if-no-files-found: ignore

      - name: Fail if leaks found
        if: steps.scan.outputs.exitcode != '0'
        run: |
          echo "Gitleaks found potential secrets or scan error. See artifact: gitleaks-reports"
          exit 1

  semgrep:
    name: SAST (Semgrep) — report only
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Run Semgrep (OWASP Top 10)
        run: |
          python3 -m pip install --upgrade pip
          pip3 install semgrep
          if [ -d "app" ]; then
            semgrep --config p/owasp-top-ten --json -o semgrep.json app || true
          else
            echo "{}" > semgrep.json
          fi

      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: semgrep.json
          path: semgrep.json

  trivy:
    name: Image Scan + SBOM — report only
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Trivy
        run: |
          set -e
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh \
            | sh -s -- -b /usr/local/bin
          trivy --version

      - name: Scan Docker Hub image
        run: |
          set -e
          IMG=bkimminich/juice-shop:latest
          trivy image --severity HIGH,CRITICAL --exit-code 0 --format json --output trivy.json "$IMG"
          trivy image --format spdx-json --output sbom-spdx.json "$IMG"

      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: trivy.json
          path: trivy.json

      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: sbom-spdx.json
          path: sbom-spdx.json

  deploy:
    name: Terraform Apply → ECR Retag → ECS Deploy → ZAP
    needs: [gitleaks, semgrep, trivy]
    runs-on: ubuntu-latest
    if: ${{ vars.AWS_ROLE_ARN != '' && vars.AWS_ACCOUNT_ID != '' && vars.AWS_REGION != '' }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Terraform init/apply (DockerHub image for first boot)
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -e
          terraform init -input=false
          terraform workspace select dev || terraform workspace new dev
          terraform apply -auto-approve \
            -var="region=${{ vars.AWS_REGION }}" \
            -var="image_uri=bkimminich/juice-shop:latest"

      - name: Ensure ECR repo exists & login
        run: |
          set -e
          AWS_ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID }}"
          AWS_REGION="${{ vars.AWS_REGION }}"
          aws ecr describe-repositories --repository-names "$ECR_REPO_NAME" >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name "$ECR_REPO_NAME"
          aws ecr get-login-password | docker login --username AWS --password-stdin \
            "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Pull, retag, push to ECR
        run: |
          set -e
          AWS_ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID }}"
          AWS_REGION="${{ vars.AWS_REGION }}"
          SRC=bkimminich/juice-shop:latest
          DST="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}:${{ github.sha }}"
          docker pull "$SRC"
          docker tag  "$SRC" "$DST"
          docker push "$DST"
          echo "ECR_IMAGE=$DST" >> "$GITHUB_ENV"

      - name: Re-apply Terraform with ECR image (updates ECS service)
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -e
          terraform apply -auto-approve \
            -var="region=${{ vars.AWS_REGION }}" \
            -var="image_uri=$ECR_IMAGE"

      - name: Get ALB DNS
        id: tfout
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -e
          echo "alb=$(terraform output -raw alb_dns_name)" >> "$GITHUB_OUTPUT"

      - name: ZAP Baseline against ALB
        run: |
          set -e
          URL="http://${{ steps.tfout.outputs.alb }}"
          docker run --rm -t -v "$PWD:/zap/wrk" ghcr.io/zaproxy/zaproxy:stable \
            /zap/zap-baseline.py -t "$URL" -m 3 -r zap-baseline.html -x zap-baseline.xml || true
          ls -l

      - uses: actions/upload-artifact@v4
        with:
          name: zap-baseline
          path: zap-baseline.*
