name: Main CI/CD

on:
  push:
  pull_request:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read
  security-events: write
  actions: read

env:
  TF_DIR: infra
  ECR_REPO_NAME: tangled-web-lab-dev-app
  TERRAFORM_VERSION: 1.9.5
  TARGET_IMAGE: bkimminich/juice-shop:latest

jobs:
  # Parallel security scanning for faster feedback
  security-scans:
    name: Security Scans
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        scanner:
          - name: gitleaks
            upload_sarif: true
          - name: semgrep
            upload_sarif: false
          - name: trivy
            upload_sarif: true
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        if: matrix.scanner.name == 'gitleaks'
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          config-path: .gitleaks.toml
        continue-on-error: true

      - name: Run Semgrep
        if: matrix.scanner.name == 'semgrep'
        uses: semgrep/semgrep-action@v1
        with:
          config: p/owasp-top-ten
          generateSarif: "1"
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
        continue-on-error: true

      - name: Run Trivy vulnerability scanner
        if: matrix.scanner.name == 'trivy'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.TARGET_IMAGE }}
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      - name: Upload SARIF file to GitHub Security
        if: matrix.scanner.upload_sarif && always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ matrix.scanner.name == 'trivy' && 'trivy-results.sarif' || format('{0}-results.sarif', matrix.scanner.name) }}
          category: ${{ matrix.scanner.name }}

      - name: Generate SBOM
        if: matrix.scanner.name == 'trivy'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.TARGET_IMAGE }}
          format: 'spdx-json'
          output: 'sbom-spdx.json'

      - name: Upload scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ${{ matrix.scanner.name }}-results
          path: |
            ${{ matrix.scanner.name }}*.sarif
            ${{ matrix.scanner.name }}*.json
            trivy-results.sarif
            sbom-spdx.json
          if-no-files-found: ignore

  # Build and prepare deployment
  build:
    name: Build & Prepare
    runs-on: ubuntu-latest
    needs: security-scans
    if: ${{ !cancelled() && (success() || needs.security-scans.result == 'failure') }}
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.TARGET_IMAGE }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # For this example, we're just validating the target image exists
      # In a real scenario, you'd build your own image here
      - name: Pull and verify target image
        id: build
        run: |
          docker pull ${{ env.TARGET_IMAGE }}
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ env.TARGET_IMAGE }} | cut -d'@' -f2)
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "Successfully verified image: ${{ env.TARGET_IMAGE }}"

  # Infrastructure deployment
  deploy:
    name: Deploy Infrastructure
    needs: [security-scans, build]
    runs-on: ubuntu-latest
    if: ${{ vars.AWS_ROLE_ARN != '' && vars.AWS_ACCOUNT_ID != '' && vars.AWS_REGION != '' && !cancelled() }}
    environment: 
      name: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
      url: ${{ steps.deploy.outputs.app_url }}
    
    outputs:
      app_url: ${{ steps.deploy.outputs.app_url }}
      alb_dns: ${{ steps.deploy.outputs.alb_dns }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}
          role-session-name: GitHubActions-${{ github.run_id }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Terraform Format Check
        working-directory: ${{ env.TF_DIR }}
        run: terraform fmt -check -diff

      - name: Terraform Init
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform init -input=false
          
      - name: Terraform Plan
        working-directory: ${{ env.TF_DIR }}
        run: |
          WORKSPACE=${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
          terraform workspace select $WORKSPACE || terraform workspace new $WORKSPACE
          terraform plan -input=false \
            -var="region=${{ vars.AWS_REGION }}" \
            -var="image_uri=${{ env.TARGET_IMAGE }}" \
            -out=tfplan

      - name: Terraform Apply
        working-directory: ${{ env.TF_DIR }}
        run: terraform apply -input=false tfplan

      - name: Get infrastructure outputs
        id: tf_outputs
        working-directory: ${{ env.TF_DIR }}
        run: |
          ALB_DNS=$(terraform output -raw alb_dns_name 2>/dev/null || echo "")
          if [[ -z "$ALB_DNS" ]]; then
            echo "Error: Could not retrieve ALB DNS name from Terraform outputs"
            exit 1
          fi
          echo "alb_dns=$ALB_DNS" >> $GITHUB_OUTPUT
          echo "app_url=http://$ALB_DNS" >> $GITHUB_OUTPUT

      - name: Configure ECR and retag image
        run: |
          # Create ECR repository if it doesn't exist
          aws ecr describe-repositories --repository-names "$ECR_REPO_NAME" 2>/dev/null || \
            aws ecr create-repository --repository-name "$ECR_REPO_NAME" --image-scanning-configuration scanOnPush=true

          # Login to ECR
          aws ecr get-login-password --region ${{ vars.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com

          # Pull, tag, and push image
          ECR_URI="${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com/$ECR_REPO_NAME:${{ github.sha }}"
          docker pull ${{ env.TARGET_IMAGE }}
          docker tag ${{ env.TARGET_IMAGE }} "$ECR_URI"
          docker push "$ECR_URI"
          echo "ECR_IMAGE=$ECR_URI" >> $GITHUB_ENV

      - name: Update ECS service with new image
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform apply -auto-approve -input=false \
            -var="region=${{ vars.AWS_REGION }}" \
            -var="image_uri=$ECR_IMAGE"

      - name: Wait for service to be stable
        id: deploy
        run: |
          echo "Waiting for ECS service to stabilize..."
          # Add your ECS service name here
          # aws ecs wait services-stable --cluster your-cluster --services your-service
          
          ALB_DNS="${{ steps.tf_outputs.outputs.alb_dns }}"
          APP_URL="http://$ALB_DNS"
          
          # Wait for ALB to respond (up to 5 minutes)
          timeout 300 bash -c "
            while ! curl -f -s --max-time 10 '$APP_URL' >/dev/null; do
              echo 'Waiting for application to be available...'
              sleep 15
            done
          " || {
            echo "Application failed to become available within timeout"
            exit 1
          }
          
          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
          echo "alb_dns=$ALB_DNS" >> $GITHUB_OUTPUT
          echo "‚úÖ Application deployed successfully at: $APP_URL"

  # Security testing against live deployment
  security-testing:
    name: Security Testing
    needs: deploy
    runs-on: ubuntu-latest
    if: ${{ needs.deploy.result == 'success' }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.12.0
        with:
          target: ${{ needs.deploy.outputs.app_url }}
          rules_file_name: '.zap/rules.tsv'
          cmd_options: '-a'
        continue-on-error: true

      - name: Upload ZAP results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: zap-results
          path: report_*

  # Rollback capability
  rollback:
    name: Rollback on Failure
    needs: [deploy, security-testing]
    runs-on: ubuntu-latest
    if: ${{ failure() && needs.deploy.result == 'success' }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Rollback
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform init -input=false
          WORKSPACE=${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
          terraform workspace select $WORKSPACE
          
          echo "‚ö†Ô∏è Rolling back to previous stable state..."
          # This would rollback to previous image or destroy resources
          # terraform apply -auto-approve -var="image_uri=${{ env.TARGET_IMAGE }}"
          
          echo "üîÑ Rollback completed"

  # Cleanup job
  cleanup:
    name: Cleanup
    needs: [deploy, security-testing, rollback]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Clean up temporary resources
        run: |
          echo "üßπ Cleaning up temporary resources..."
          # Add cleanup logic here if needed